From 68054ecc60fdf4bf7b2de3c82caf181347b16c08 Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Mon, 21 Aug 2023 16:10:20 -0400
Subject: [PATCH] meson64 general patch set

source: https://github.com/tobetter/linux

Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 .../display/panel/ilitek,ili9881c.yaml        |   1 +
 drivers/gpu/drm/meson/meson_vclk.c            |  18 +
 drivers/gpu/drm/meson/meson_venc.c            |   2 +-
 drivers/gpu/drm/meson/meson_viu.c             |   2 +
 drivers/gpu/drm/panel/panel-ilitek-ili9881c.c | 236 ++++++++
 drivers/gpu/drm/tiny/ili9341.c                |   2 +
 drivers/hid/hid-ids.h                         |   6 +
 drivers/hid/hid-quirks.c                      |   3 +
 drivers/i2c/busses/i2c-rk3x.c                 |  32 +
 drivers/input/touchscreen/Kconfig             |  10 +
 drivers/input/touchscreen/Makefile            |   1 +
 drivers/input/touchscreen/dwav-usb-mt.c       | 554 ++++++++++++++++++
 drivers/input/touchscreen/goodix.c            |   3 +
 drivers/pinctrl/meson/pinctrl-meson.c         |  35 ++
 drivers/pinctrl/meson/pinctrl-meson.h         |   1 +
 drivers/spi/spidev.c                          |   2 +
 include/drm/drm_mipi_dbi.h                    |   7 +-
 sound/soc/meson/Kconfig                       |   2 +
 sound/soc/meson/axg-frddr.c                   |   4 +-
 19 files changed, 912 insertions(+), 9 deletions(-)
 create mode 100644 drivers/input/touchscreen/dwav-usb-mt.c

diff --git a/Documentation/devicetree/bindings/display/panel/ilitek,ili9881c.yaml b/Documentation/devicetree/bindings/display/panel/ilitek,ili9881c.yaml
index c5d1df680858..0f47414e3375 100644
--- a/Documentation/devicetree/bindings/display/panel/ilitek,ili9881c.yaml
+++ b/Documentation/devicetree/bindings/display/panel/ilitek,ili9881c.yaml
@@ -17,6 +17,7 @@ properties:
     items:
       - enum:
           - bananapi,lhr050h41
+          - elida,hj080be31ia1
           - feixin,k101-im2byl02
           - wanchanglong,w552946aba
       - const: ilitek,ili9881c
diff --git a/drivers/gpu/drm/meson/meson_vclk.c b/drivers/gpu/drm/meson/meson_vclk.c
index 2a82119eb58e..eb4c251d79b7 100644
--- a/drivers/gpu/drm/meson/meson_vclk.c
+++ b/drivers/gpu/drm/meson/meson_vclk.c
@@ -357,6 +357,8 @@ enum {
 	MESON_VCLK_HDMI_594000,
 /* 2970 /1 /1 /1 /5 /1  => /1 /2 */
 	MESON_VCLK_HDMI_594000_YUV420,
+/* 4830 /2 /1 /2 /5 /1  => /1 /1 */
+	MESON_VCLK_HDMI_241500,
 };
 
 struct meson_vclk_params {
@@ -467,6 +469,18 @@ struct meson_vclk_params {
 		.vid_pll_div = VID_PLL_DIV_5,
 		.vclk_div = 1,
 	},
+	[MESON_VCLK_HDMI_241500] = {
+		.pll_freq = 4830000,
+		.phy_freq = 2415000,
+		.venc_freq = 241500,
+		.vclk_freq = 241500,
+		.pixel_freq = 241500,
+		.pll_od1 = 2,
+		.pll_od2 = 1,
+		.pll_od3 = 2,
+		.vid_pll_div = VID_PLL_DIV_5,
+		.vclk_div = 1,
+	},
 	{ /* sentinel */ },
 };
 
@@ -873,6 +887,10 @@ static void meson_vclk_set(struct meson_drm *priv, unsigned int pll_base_freq,
 			m = 0xf7;
 			frac = vic_alternate_clock ? 0x8148 : 0x10000;
 			break;
+		case 4830000:
+			m = 0xc9;
+			frac = 0xd560;
+			break;
 		}
 
 		meson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);
diff --git a/drivers/gpu/drm/meson/meson_venc.c b/drivers/gpu/drm/meson/meson_venc.c
index fcd532db19c1..ed532b0cae35 100644
--- a/drivers/gpu/drm/meson/meson_venc.c
+++ b/drivers/gpu/drm/meson/meson_venc.c
@@ -866,7 +866,7 @@ meson_venc_hdmi_supported_mode(const struct drm_display_mode *mode)
 			    DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC))
 		return MODE_BAD;
 
-	if (mode->hdisplay < 400 || mode->hdisplay > 1920)
+	if (mode->hdisplay < 400 || mode->hdisplay > 2560)
 		return MODE_BAD_HVALUE;
 
 	if (mode->vdisplay < 480 || mode->vdisplay > 1920)
diff --git a/drivers/gpu/drm/meson/meson_viu.c b/drivers/gpu/drm/meson/meson_viu.c
index cd399b0b7181..4b155367c115 100644
--- a/drivers/gpu/drm/meson/meson_viu.c
+++ b/drivers/gpu/drm/meson/meson_viu.c
@@ -425,6 +425,7 @@ void meson_viu_init(struct meson_drm *priv)
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
 	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))
 		meson_viu_load_matrix(priv);
+#if 0
 	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		meson_viu_set_g12a_osd1_matrix(priv, RGB709_to_YUV709l_coeff,
 					       true);
@@ -433,6 +434,7 @@ void meson_viu_init(struct meson_drm *priv)
 				OSD1_HDR2_CTRL_VDIN0_HDR2_TOP_EN, 0,
 				priv->io_base + _REG(OSD1_HDR2_CTRL));
 	}
+#endif
 
 	/* Initialize OSD1 fifo control register */
 	reg = VIU_OSD_DDR_PRIORITY_URGENT |
diff --git a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
index 1ec696adf9de..eac81724cede 100644
--- a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
+++ b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
@@ -662,6 +662,216 @@ static const struct ili9881c_instr w552946ab_init[] = {
 	ILI9881C_SWITCH_PAGE_INSTR(0),
 };
 
+static const struct ili9881c_instr hj080be31ia1_init[] = {
+	ILI9881C_SWITCH_PAGE_INSTR(3),
+	ILI9881C_COMMAND_INSTR(0x01, 0x00),
+	ILI9881C_COMMAND_INSTR(0x02, 0x00),
+	ILI9881C_COMMAND_INSTR(0x03, 0x53),
+	ILI9881C_COMMAND_INSTR(0x04, 0x53),
+	ILI9881C_COMMAND_INSTR(0x05, 0x13),
+	ILI9881C_COMMAND_INSTR(0x06, 0x04),
+	ILI9881C_COMMAND_INSTR(0x07, 0x02),
+	ILI9881C_COMMAND_INSTR(0x08, 0x02),
+	ILI9881C_COMMAND_INSTR(0x09, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0a, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0b, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0c, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0d, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0e, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0f, 0x00),
+	ILI9881C_COMMAND_INSTR(0x10, 0x00),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+	ILI9881C_COMMAND_INSTR(0x12, 0x00),
+	ILI9881C_COMMAND_INSTR(0x13, 0x00),
+	ILI9881C_COMMAND_INSTR(0x14, 0x00),
+	ILI9881C_COMMAND_INSTR(0x15, 0x00),
+	ILI9881C_COMMAND_INSTR(0x16, 0x00),
+	ILI9881C_COMMAND_INSTR(0x17, 0x00),
+	ILI9881C_COMMAND_INSTR(0x18, 0x00),
+	ILI9881C_COMMAND_INSTR(0x19, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1a, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1b, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1c, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1d, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1e, 0xc0),
+	ILI9881C_COMMAND_INSTR(0x1f, 0x80),
+	ILI9881C_COMMAND_INSTR(0x20, 0x02),
+	ILI9881C_COMMAND_INSTR(0x21, 0x09),
+	ILI9881C_COMMAND_INSTR(0x22, 0x00),
+	ILI9881C_COMMAND_INSTR(0x23, 0x00),
+	ILI9881C_COMMAND_INSTR(0x24, 0x00),
+	ILI9881C_COMMAND_INSTR(0x25, 0x00),
+	ILI9881C_COMMAND_INSTR(0x26, 0x00),
+	ILI9881C_COMMAND_INSTR(0x27, 0x00),
+	ILI9881C_COMMAND_INSTR(0x28, 0x55),
+	ILI9881C_COMMAND_INSTR(0x29, 0x03),
+	ILI9881C_COMMAND_INSTR(0x2a, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2b, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2c, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2d, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2e, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2f, 0x00),
+	ILI9881C_COMMAND_INSTR(0x30, 0x00),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x32, 0x00),
+	ILI9881C_COMMAND_INSTR(0x33, 0x00),
+	ILI9881C_COMMAND_INSTR(0x34, 0x00),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x36, 0x00),
+	ILI9881C_COMMAND_INSTR(0x37, 0x00),
+	ILI9881C_COMMAND_INSTR(0x38, 0x3C), /* VDD1&2 toggle 1sec */
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3a, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3b, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3c, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3d, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3e, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3f, 0x00),
+	ILI9881C_COMMAND_INSTR(0x40, 0x00),
+	ILI9881C_COMMAND_INSTR(0x41, 0x00),
+	ILI9881C_COMMAND_INSTR(0x42, 0x00),
+	ILI9881C_COMMAND_INSTR(0x43, 0x00),
+	ILI9881C_COMMAND_INSTR(0x44, 0x00),
+
+	ILI9881C_COMMAND_INSTR(0x50, 0x01),
+	ILI9881C_COMMAND_INSTR(0x51, 0x23),
+	ILI9881C_COMMAND_INSTR(0x52, 0x45),
+	ILI9881C_COMMAND_INSTR(0x53, 0x67),
+	ILI9881C_COMMAND_INSTR(0x54, 0x89),
+	ILI9881C_COMMAND_INSTR(0x55, 0xab),
+	ILI9881C_COMMAND_INSTR(0x56, 0x01),
+	ILI9881C_COMMAND_INSTR(0x57, 0x23),
+	ILI9881C_COMMAND_INSTR(0x58, 0x45),
+	ILI9881C_COMMAND_INSTR(0x59, 0x67),
+	ILI9881C_COMMAND_INSTR(0x5a, 0x89),
+	ILI9881C_COMMAND_INSTR(0x5b, 0xab),
+	ILI9881C_COMMAND_INSTR(0x5c, 0xcd),
+	ILI9881C_COMMAND_INSTR(0x5d, 0xef),
+
+	ILI9881C_COMMAND_INSTR(0x5e, 0x01),
+	ILI9881C_COMMAND_INSTR(0x5f, 0x08), /* FW_GOUT_L1   STV2_ODD */
+	ILI9881C_COMMAND_INSTR(0x60, 0x02), /* FW_GOUT_L2 */
+	ILI9881C_COMMAND_INSTR(0x61, 0x02), /* FW_GOUT_L3 */
+	ILI9881C_COMMAND_INSTR(0x62, 0x0A), /* FW_GOUT_L4   RESET_ODD */
+	ILI9881C_COMMAND_INSTR(0x63, 0x15), /* FW_GOUT_L5 */
+	ILI9881C_COMMAND_INSTR(0x64, 0x14), /* FW_GOUT_L6 */
+	ILI9881C_COMMAND_INSTR(0x65, 0x02), /* FW_GOUT_L7 */
+	ILI9881C_COMMAND_INSTR(0x66, 0x11), /* FW_GOUT_L8    CK11 */
+	ILI9881C_COMMAND_INSTR(0x67, 0x10), /* FW_GOUT_L9    CK9 */
+	ILI9881C_COMMAND_INSTR(0x68, 0x02), /* FW_GOUT_L10 */
+	ILI9881C_COMMAND_INSTR(0x69, 0x0F), /* FW_GOUT_L11   CK7 */
+	ILI9881C_COMMAND_INSTR(0x6a, 0x0E), /* FW_GOUT_L12   CK5 */
+	ILI9881C_COMMAND_INSTR(0x6b, 0x02), /* FW_GOUT_L13 */
+	ILI9881C_COMMAND_INSTR(0x6c, 0x0D), /* FW_GOUT_L14   CK3 */
+	ILI9881C_COMMAND_INSTR(0x6d, 0x0C), /* FW_GOUT_L15   CK1 */
+	ILI9881C_COMMAND_INSTR(0x6e, 0x06), /* FW_GOUT_L16   STV1_ODD */
+	ILI9881C_COMMAND_INSTR(0x6f, 0x02), /* FW_GOUT_L17 */
+	ILI9881C_COMMAND_INSTR(0x70, 0x02), /* FW_GOUT_L18 */
+	ILI9881C_COMMAND_INSTR(0x71, 0x02), /* FW_GOUT_L19 */
+	ILI9881C_COMMAND_INSTR(0x72, 0x02), /* FW_GOUT_L20 */
+	ILI9881C_COMMAND_INSTR(0x73, 0x02), /* FW_GOUT_L21 */
+	ILI9881C_COMMAND_INSTR(0x74, 0x02), /* FW_GOUT_L22 */
+
+	ILI9881C_COMMAND_INSTR(0x75, 0x06), /* BW_GOUT_L1   STV2_ODD */
+	ILI9881C_COMMAND_INSTR(0x76, 0x02), /* BW_GOUT_L2 */
+	ILI9881C_COMMAND_INSTR(0x77, 0x02), /* BW_GOUT_L3 */
+	ILI9881C_COMMAND_INSTR(0x78, 0x0A), /* BW_GOUT_L4   RESET_ODD */
+	ILI9881C_COMMAND_INSTR(0x79, 0x15), /* BW_GOUT_L5 */
+	ILI9881C_COMMAND_INSTR(0x7a, 0x14), /* BW_GOUT_L6 */
+	ILI9881C_COMMAND_INSTR(0x7b, 0x02), /* BW_GOUT_L7 */
+	ILI9881C_COMMAND_INSTR(0x7c, 0x10), /* BW_GOUT_L8  CK11 */
+	ILI9881C_COMMAND_INSTR(0x7d, 0x11), /* BW_GOUT_L9  CK9 */
+	ILI9881C_COMMAND_INSTR(0x7e, 0x02), /* BW_GOUT_L10 */
+	ILI9881C_COMMAND_INSTR(0x7f, 0x0C), /* BW_GOUT_L11 CK7 */
+	ILI9881C_COMMAND_INSTR(0x80, 0x0D), /* BW_GOUT_L12 CK5 */
+	ILI9881C_COMMAND_INSTR(0x81, 0x02), /* BW_GOUT_L13 */
+	ILI9881C_COMMAND_INSTR(0x82, 0x0E), /* BW_GOUT_L14 CK3 */
+	ILI9881C_COMMAND_INSTR(0x83, 0x0F), /* BW_GOUT_L15 CK1 */
+	ILI9881C_COMMAND_INSTR(0x84, 0x08), /* BW_GOUT_L16 STV1_ODD */
+	ILI9881C_COMMAND_INSTR(0x85, 0x02), /* BW_GOUT_L17 */
+	ILI9881C_COMMAND_INSTR(0x86, 0x02), /* BW_GOUT_L18 */
+	ILI9881C_COMMAND_INSTR(0x87, 0x02), /* BW_GOUT_L19 */
+	ILI9881C_COMMAND_INSTR(0x88, 0x02), /* BW_GOUT_L20 */
+	ILI9881C_COMMAND_INSTR(0x89, 0x02), /* BW_GOUT_L21 */
+	ILI9881C_COMMAND_INSTR(0x8A, 0x02), /* BW_GOUT_L22 */
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x30), /* VGH clamp 16.08V */
+	ILI9881C_COMMAND_INSTR(0x6F, 0x37), /* reg vcl + pumping ratio VGH=3x VGL=-3x */
+	ILI9881C_COMMAND_INSTR(0x8D, 0x1F), /* VGL clamp -12.03V */
+	ILI9881C_COMMAND_INSTR(0x87, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x26, 0x76),
+	ILI9881C_COMMAND_INSTR(0xB2, 0xD1),
+	ILI9881C_COMMAND_INSTR(0xB5, 0x07),
+	ILI9881C_COMMAND_INSTR(0x35, 0x17),
+	ILI9881C_COMMAND_INSTR(0x33, 0x14),
+	ILI9881C_COMMAND_INSTR(0x31, 0x75),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x85),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x98),
+	ILI9881C_COMMAND_INSTR(0x38, 0x01),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x7A, 0x10), /* VREG1/2 out */
+	ILI9881C_SWITCH_PAGE_INSTR(1),
+	ILI9881C_COMMAND_INSTR(0x40, 0x53),
+	ILI9881C_COMMAND_INSTR(0x22, 0x0A),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00), /* column inversion */
+	ILI9881C_COMMAND_INSTR(0x50, 0xE9), /* VREG1OUT=5.508V */
+	ILI9881C_COMMAND_INSTR(0x51, 0xE4), /* VREG2OUT=-5.508V */
+	ILI9881C_COMMAND_INSTR(0x53, 0x48), /* VCOM1 */
+	ILI9881C_COMMAND_INSTR(0x55, 0x48), /* VCOM2 */
+	ILI9881C_COMMAND_INSTR(0x60, 0x28), /* SDT */
+	ILI9881C_COMMAND_INSTR(0x2E, 0xC8), /* 1280 GATE NL SEL */
+	ILI9881C_COMMAND_INSTR(0x34, 0x01),
+	ILI9881C_COMMAND_INSTR(0xA0, 0x00), /* VP255 */
+	ILI9881C_COMMAND_INSTR(0xA1, 0x13), /* VP251 */
+	ILI9881C_COMMAND_INSTR(0xA2, 0x24), /* VP247 */
+	ILI9881C_COMMAND_INSTR(0xA3, 0x15), /* VP243 */
+	ILI9881C_COMMAND_INSTR(0xA4, 0x18), /* VP239 */
+	ILI9881C_COMMAND_INSTR(0xA5, 0x2F), /* VP231 */
+	ILI9881C_COMMAND_INSTR(0xA6, 0x22), /* VP219 */
+	ILI9881C_COMMAND_INSTR(0xA7, 0x21), /* VP203 */
+	ILI9881C_COMMAND_INSTR(0xA8, 0x89), /* VP175 */
+	ILI9881C_COMMAND_INSTR(0xA9, 0x1B), /* VP144 */
+	ILI9881C_COMMAND_INSTR(0xAA, 0x27), /* VP111 */
+	ILI9881C_COMMAND_INSTR(0xAB, 0x7D), /* VP80 */
+	ILI9881C_COMMAND_INSTR(0xAC, 0x1B), /* VP52 */
+	ILI9881C_COMMAND_INSTR(0xAD, 0x1B), /* VP36 */
+	ILI9881C_COMMAND_INSTR(0xAE, 0x50), /* VP24 */
+	ILI9881C_COMMAND_INSTR(0xAF, 0x24), /* VP16 */
+	ILI9881C_COMMAND_INSTR(0xB0, 0x2A), /* VP12 */
+	ILI9881C_COMMAND_INSTR(0xB1, 0x51), /* VP8 */
+	ILI9881C_COMMAND_INSTR(0xB2, 0x5A), /* VP4 */
+	ILI9881C_COMMAND_INSTR(0xB3, 0x1B), /* VP0 */
+	ILI9881C_COMMAND_INSTR(0xC0, 0x00), /* VN255 GAMMA N */
+	ILI9881C_COMMAND_INSTR(0xC1, 0x16), /* VN251 */
+	ILI9881C_COMMAND_INSTR(0xC2, 0x24), /* VN247 */
+	ILI9881C_COMMAND_INSTR(0xC3, 0x13), /* VN243 */
+	ILI9881C_COMMAND_INSTR(0xC4, 0x18), /* VN239 */
+	ILI9881C_COMMAND_INSTR(0xC5, 0x2A), /* VN231 */
+	ILI9881C_COMMAND_INSTR(0xC6, 0x20), /* VN219 */
+	ILI9881C_COMMAND_INSTR(0xC7, 0x22), /* VN203 */
+	ILI9881C_COMMAND_INSTR(0xC8, 0x80), /* VN175 */
+	ILI9881C_COMMAND_INSTR(0xC9, 0x1C), /* VN144 */
+	ILI9881C_COMMAND_INSTR(0xCA, 0x28), /* VN111 */
+	ILI9881C_COMMAND_INSTR(0xCB, 0x71), /* VN80 */
+	ILI9881C_COMMAND_INSTR(0xCC, 0x1D), /* VN52 */
+	ILI9881C_COMMAND_INSTR(0xCD, 0x1B), /* VN36 */
+	ILI9881C_COMMAND_INSTR(0xCE, 0x51), /* VN24 */
+	ILI9881C_COMMAND_INSTR(0xCF, 0x24), /* VN16 */
+	ILI9881C_COMMAND_INSTR(0xD0, 0x2A), /* VN12 */
+	ILI9881C_COMMAND_INSTR(0xD1, 0x4C), /* VN8 */
+	ILI9881C_COMMAND_INSTR(0xD2, 0x5A), /* VN4 */
+	ILI9881C_COMMAND_INSTR(0xD3, 0x32), /* VN0 */
+	ILI9881C_SWITCH_PAGE_INSTR(2),
+	ILI9881C_COMMAND_INSTR(0x04, 0x17),
+	ILI9881C_COMMAND_INSTR(0x05, 0x12),
+	ILI9881C_COMMAND_INSTR(0x06, 0x40),
+	ILI9881C_COMMAND_INSTR(0x07, 0x0B),
+
+	ILI9881C_SWITCH_PAGE_INSTR(0),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+};
+
 static inline struct ili9881c *panel_to_ili9881c(struct drm_panel *panel)
 {
 	return container_of(panel, struct ili9881c, panel);
@@ -812,6 +1022,23 @@ static const struct drm_display_mode k101_im2byl02_default_mode = {
 	.height_mm	= 217,
 };
 
+static const struct drm_display_mode hj080be31ia1_default_mode = {
+	.clock		= 66000,
+
+	.hdisplay	= 800,
+	.hsync_start	= 800 + 32,
+	.hsync_end	= 800 + 32 + 24,
+	.htotal		= 800 + 32 + 24 + 24,
+
+	.vdisplay	= 1280,
+	.vsync_start	= 1280 + 8,
+	.vsync_end	= 1280 + 8 + 4,
+	.vtotal		= 1280 + 8 + 4 + 8,
+
+	.width_mm	= 108,
+	.height_mm	= 172,
+};
+
 static const struct drm_display_mode w552946aba_default_mode = {
 	.clock		= 64000,
 
@@ -944,6 +1171,14 @@ static const struct ili9881c_desc k101_im2byl02_desc = {
 	.mode_flags = MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
 };
 
+static const struct ili9881c_desc hj080be31ia1_desc = {
+	.init = hj080be31ia1_init,
+	.init_length = ARRAY_SIZE(hj080be31ia1_init),
+	.mode = &hj080be31ia1_default_mode,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		      MIPI_DSI_MODE_NO_EOT_PACKET,
+};
+
 static const struct ili9881c_desc w552946aba_desc = {
 	.init = w552946ab_init,
 	.init_length = ARRAY_SIZE(w552946ab_init),
@@ -954,6 +1189,7 @@ static const struct ili9881c_desc w552946aba_desc = {
 
 static const struct of_device_id ili9881c_of_match[] = {
 	{ .compatible = "bananapi,lhr050h41", .data = &lhr050h41_desc },
+	{ .compatible = "elida,hj080be31ia1", .data = &hj080be31ia1_desc },
 	{ .compatible = "feixin,k101-im2byl02", .data = &k101_im2byl02_desc },
 	{ .compatible = "wanchanglong,w552946aba", .data = &w552946aba_desc },
 	{ }
diff --git a/drivers/gpu/drm/tiny/ili9341.c b/drivers/gpu/drm/tiny/ili9341.c
index 47b61c3bf145..269d575e5cac 100644
--- a/drivers/gpu/drm/tiny/ili9341.c
+++ b/drivers/gpu/drm/tiny/ili9341.c
@@ -160,12 +160,14 @@ static const struct drm_driver ili9341_driver = {
 
 static const struct of_device_id ili9341_of_match[] = {
 	{ .compatible = "adafruit,yx240qv29" },
+	{ .compatible = "hardkernel,hktft32" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9341_of_match);
 
 static const struct spi_device_id ili9341_id[] = {
 	{ "yx240qv29", 0 },
+	{ "hktft32", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(spi, ili9341_id);
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 55a436a6dde9..4c14594a0a82 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -1442,4 +1442,10 @@
 #define USB_VENDOR_ID_SIGNOTEC			0x2133
 #define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011	0x0018
 
+#define USB_DEVICE_ID_DWAV_MULTITOUCH	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define USB_DEVICE_ID_VU5	0x0704
+#define USB_DEVICE_ID_VU7PLUS	0x0705
+
 #endif
diff --git a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c
index 3983b4f282f8..38217748b1ec 100644
--- a/drivers/hid/hid-quirks.c
+++ b/drivers/hid/hid-quirks.c
@@ -888,6 +888,9 @@ static const struct hid_device_id hid_ignore_list[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },
 #endif
 	{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS) },
 	{ }
 };
 
diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c
index b31cf4f18f85..dc58942796d1 100644
--- a/drivers/i2c/busses/i2c-rk3x.c
+++ b/drivers/i2c/busses/i2c-rk3x.c
@@ -1228,6 +1228,32 @@ static const struct of_device_id rk3x_i2c_match[] = {
 };
 MODULE_DEVICE_TABLE(of, rk3x_i2c_match);
 
+static ssize_t rk3x_i2c_get_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct rk3x_i2c *i2c = dev_get_drvdata(dev);
+	struct i2c_timings *t = &i2c->t;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", t->bus_freq_hz);
+}
+
+static ssize_t rk3x_i2c_set_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct rk3x_i2c *i2c = dev_get_drvdata(dev);
+	struct i2c_timings *t = &i2c->t;
+	int ret, freq;
+
+	ret = kstrtoint(buf, 10, &freq);
+	if (ret < 0)
+		return ret;
+
+	t->bus_freq_hz = (uint32_t)freq;
+	rk3x_i2c_adapt_div(i2c, clk_get_rate(i2c->clk));
+
+	return count;
+}
+
+DEVICE_ATTR(speed, S_IRUGO | S_IWUSR, rk3x_i2c_get_speed, rk3x_i2c_set_speed);
+
 static int rk3x_i2c_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -1243,6 +1269,11 @@ static int rk3x_i2c_probe(struct platform_device *pdev)
 	if (!i2c)
 		return -ENOMEM;
 
+	ret = device_create_file(&pdev->dev, &dev_attr_speed);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to create speed attribute file: %d\n", ret);
+	}
+
 	match = of_match_node(rk3x_i2c_match, np);
 	i2c->soc_data = match->data;
 
@@ -1378,6 +1409,7 @@ static int rk3x_i2c_remove(struct platform_device *pdev)
 
 	i2c_del_adapter(&i2c->adap);
 
+	device_remove_file(&pdev->dev, &dev_attr_speed);
 	clk_notifier_unregister(i2c->clk, &i2c->clk_rate_nb);
 	clk_unprepare(i2c->pclk);
 	clk_unprepare(i2c->clk);
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 143ff43c67ae..e1f2587fcfec 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -325,6 +325,16 @@ config TOUCHSCREEN_DA9052
 	  To compile this driver as a module, choose M here: the
 	  module will be called da9052_tsi.
 
+config TOUCHSCREEN_DWAV_USB_MT
+	tristate "D-WAV Scientific USB MultiTouch"
+	depends on USB_ARCH_HAS_HCD
+	select USB
+	help
+	  Say Y here if you have a D-WAV Scientific USB(HID) based MultiTouch
+	  controller.
+
+	  module will be called dwav-usb-mt.
+
 config TOUCHSCREEN_DYNAPRO
 	tristate "Dynapro serial touchscreen"
 	select SERIO
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 159cd5136fdb..004b4091ea75 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_TOUCHSCREEN_CYTTSP4_SPI)	+= cyttsp4_spi.o
 obj-$(CONFIG_TOUCHSCREEN_CYTTSP5)	+= cyttsp5.o
 obj-$(CONFIG_TOUCHSCREEN_DA9034)	+= da9034-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DA9052)	+= da9052_tsi.o
+obj-$(CONFIG_TOUCHSCREEN_DWAV_USB_MT)	+= dwav-usb-mt.o
 obj-$(CONFIG_TOUCHSCREEN_DYNAPRO)	+= dynapro.o
 obj-$(CONFIG_TOUCHSCREEN_EDT_FT5X06)	+= edt-ft5x06.o
 obj-$(CONFIG_TOUCHSCREEN_HAMPSHIRE)	+= hampshire.o
diff --git a/drivers/input/touchscreen/dwav-usb-mt.c b/drivers/input/touchscreen/dwav-usb-mt.c
new file mode 100644
index 000000000000..2e1dd0f2986f
--- /dev/null
+++ b/drivers/input/touchscreen/dwav-usb-mt.c
@@ -0,0 +1,554 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * D-WAV Scientific USB(HID) MultiTouch Screen Driver(Based on usbtouchscreen.c)
+ *
+ * Copyright (C) Hardkernel, 2015
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+
+#include <linux/input/mt.h>
+
+#define USB_VENDOR_ID_DWAV	0x0eef	/* 800 x 480, 7" DWAV touch */
+#define USB_DEVICE_ID_VU7	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define	USB_DEVICE_ID_VU5	0x0704
+#define	USB_DEVICE_ID_VU7PLUS	0x0705
+
+enum	{
+	ODROID_VU7 = 0,	/* 800 x 480, 7" Touch */
+	ODROID_VU5,	/* 800 x 480, 5" Touch */
+	ODROID_VU7PLUS,	/* 1024 x 600, 7" Touch */
+};
+
+struct usbtouch_device_info	{
+	char	name[64];
+	int	max_x;
+	int	max_y;
+	int	max_press;
+	int	max_finger;
+};
+
+const struct usbtouch_device_info DEV_INFO[] = {
+	[ODROID_VU7] = {
+		.name = "ODROID VU7 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU5] = {
+		.name = "ODROID VU5 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU7PLUS] = {
+		.name = "ODROID VU7 Plus MultiTouch(1024x600)",
+		.max_x = 1024,
+		.max_y = 600,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+};
+
+static const struct usb_device_id dwav_usb_mt_devices[] = {
+	{USB_DEVICE(USB_VENDOR_ID_DWAV,   USB_DEVICE_ID_VU7),
+		.driver_info = ODROID_VU7},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5),
+		.driver_info = ODROID_VU5},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS),
+		.driver_info = ODROID_VU7PLUS},
+	{}
+};
+
+struct dwav_raw {                   /* Total 25 bytes */
+	unsigned char   header;     /* frame header 0xAA*/
+	unsigned char   press;
+	/* Touch flag (1:valid touch data, 0:touch finished) */
+	unsigned short  x1;         /* 1st x */
+	unsigned short  y1;         /* 1st y */
+	unsigned char   end;
+	/* 1st touch finish flags 0xBB, RPI only uses the first 7 bytes */
+	unsigned char   ids;        /* touch ID(bit field) */
+	unsigned short  y2;
+	unsigned short  x2;
+	unsigned short  y3;
+	unsigned short  x3;
+	unsigned short  y4;
+	unsigned short  x4;
+	unsigned short  y5;
+	unsigned short  x5;
+	unsigned char   tail;       /* frame end 0xCC */
+};
+
+#define	TS_EVENT_UNKNOWN	0x00
+#define	TS_EVENT_PRESS		0x01
+#define	TS_EVENT_RELEASE	0x02
+
+struct	finger_t	{
+	unsigned int	status;	/* ts event type */
+	unsigned int	x;	/* ts data x */
+	unsigned int	y;	/* ts data y */
+}	__packed;
+
+struct dwav_usb_mt  {
+	char		name[128], phys[64];
+
+	int		dev_id;
+	/* for URB Data DMA */
+	dma_addr_t	data_dma;
+	unsigned char	*data;
+	int		data_size;
+
+	struct urb		*irq;
+	struct usb_interface	*interface;
+	struct input_dev	*input;
+
+	struct finger_t		*finger;
+};
+
+static void dwav_usb_mt_report(struct dwav_usb_mt *dwav_usb_mt)
+{
+	int	id, max_x, max_y, max_press, max_finger;
+
+	max_x = DEV_INFO[dwav_usb_mt->dev_id].max_x;
+	max_y = DEV_INFO[dwav_usb_mt->dev_id].max_y;
+	max_press = DEV_INFO[dwav_usb_mt->dev_id].max_press;
+	max_finger = DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+
+	for (id = 0; id < max_finger; id++)	{
+
+		if (dwav_usb_mt->finger[id].status == TS_EVENT_UNKNOWN)
+			continue;
+
+		if (dwav_usb_mt->finger[id].x >= max_x ||
+		    dwav_usb_mt->finger[id].y >= max_y)
+			continue;
+
+		input_mt_slot(dwav_usb_mt->input, id);
+
+		if (dwav_usb_mt->finger[id].status != TS_EVENT_RELEASE) {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, true);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_X,
+					dwav_usb_mt->finger[id].x);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_Y,
+					dwav_usb_mt->finger[id].y);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_PRESSURE,
+					max_press);
+		} else {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, false);
+			dwav_usb_mt->finger[id].status = TS_EVENT_UNKNOWN;
+		}
+		input_mt_report_pointer_emulation(dwav_usb_mt->input, true);
+		input_sync(dwav_usb_mt->input);
+	}
+}
+
+static void dwav_usb_mt_process(struct dwav_usb_mt *dwav_usb_mt,
+		unsigned char *pkt, int len)
+{
+	struct  dwav_raw *dwav_raw = (struct dwav_raw *)pkt;
+	unsigned char bit_mask, cnt;
+
+	for (cnt = 0, bit_mask = 0x01;
+	     cnt < DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+	     cnt++, bit_mask <<= 1) {
+		if ((dwav_raw->ids & bit_mask) && dwav_raw->press) {
+			dwav_usb_mt->finger[cnt].status = TS_EVENT_PRESS;
+			switch (cnt) {
+			case	0:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x1);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y1);
+				break;
+			case	1:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x2);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y2);
+				break;
+			case	2:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x3);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y3);
+				break;
+			case	3:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x4);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y4);
+				break;
+			case	4:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x5);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y5);
+				break;
+			default:
+				break;
+			}
+		} else {
+			if (dwav_usb_mt->finger[cnt].status == TS_EVENT_PRESS)
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_RELEASE;
+			else
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_UNKNOWN;
+		}
+	}
+	dwav_usb_mt_report(dwav_usb_mt);
+}
+
+static void dwav_usb_mt_irq(struct urb *urb)
+{
+	struct dwav_usb_mt *dwav_usb_mt = urb->context;
+	struct device *dev = &dwav_usb_mt->interface->dev;
+	int retval;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+	case -ETIME:
+		/* this urb is timing out */
+		dev_dbg(dev, "%s - urb timed out - was the device unplugged?\n",
+				__func__);
+		return;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -EPIPE:
+		/* this urb is terminated, clean up */
+		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
+				__func__, urb->status);
+		return;
+	default:
+		dev_dbg(dev, "%s - nonzero urb status received: %d\n",
+				__func__, urb->status);
+		goto exit;
+	}
+
+	dwav_usb_mt_process(dwav_usb_mt, dwav_usb_mt->data, urb->actual_length);
+
+exit:
+	usb_mark_last_busy(interface_to_usbdev(dwav_usb_mt->interface));
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval) {
+		dev_err(dev, "%s - usb_submit_urb failed with result: %d\n",
+				__func__, retval);
+	}
+}
+
+static int dwav_usb_mt_open(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	dwav_usb_mt->irq->dev = interface_to_usbdev(dwav_usb_mt->interface);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface) ? -EIO : 0;
+	if (r < 0)
+		goto out;
+
+	if (usb_submit_urb(dwav_usb_mt->irq, GFP_KERNEL)) {
+		r = -EIO;
+		goto out_put;
+	}
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 1;
+out_put:
+	usb_autopm_put_interface(dwav_usb_mt->interface);
+out:
+	return r;
+}
+
+static void dwav_usb_mt_close(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface);
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 0;
+	if (!r)
+		usb_autopm_put_interface(dwav_usb_mt->interface);
+}
+
+static int dwav_usb_mt_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	return 0;
+}
+
+static int dwav_usb_mt_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int result = 0;
+
+	mutex_lock(&input->mutex);
+	if (input->users)
+		result = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return result;
+}
+
+static int dwav_usb_mt_reset_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int err = 0;
+
+	/* restart IO if needed */
+	mutex_lock(&input->mutex);
+	if (input->users)
+		err = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return err;
+}
+
+static void dwav_usb_mt_free_buffers(struct usb_device *udev,
+				  struct dwav_usb_mt *dwav_usb_mt)
+{
+	usb_free_coherent(udev, dwav_usb_mt->data_size,
+			dwav_usb_mt->data, dwav_usb_mt->data_dma);
+}
+
+static struct usb_endpoint_descriptor *dwav_usb_mt_get_input_endpoint(
+		struct usb_host_interface *interface)
+{
+	int i;
+
+	for (i = 0; i < interface->desc.bNumEndpoints; i++) {
+		if (usb_endpoint_dir_in(&interface->endpoint[i].desc))
+			return &interface->endpoint[i].desc;
+	}
+
+	return NULL;
+}
+
+static int dwav_usb_mt_init(struct dwav_usb_mt *dwav_usb_mt, void *dev)
+{
+	int err;
+	struct input_dev *input_dev = (struct input_dev *)dev;
+
+	input_dev->name = dwav_usb_mt->name;
+	input_dev->phys = dwav_usb_mt->phys;
+
+	input_set_drvdata(input_dev, dwav_usb_mt);
+
+	input_dev->open = dwav_usb_mt_open;
+	input_dev->close = dwav_usb_mt_close;
+
+	input_dev->id.bustype = BUS_USB;
+
+	/* single touch */
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input_dev, ABS_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+
+	/* multi touch */
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+	input_mt_init_slots(input_dev,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_finger, 0);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		pr_err("%s - input_register_device failed, err: %d\n",
+				__func__, err);
+		return  err;
+	}
+
+	dwav_usb_mt->input = input_dev;
+
+	return  0;
+}
+
+static int dwav_usb_mt_probe(struct usb_interface *intf,
+			  const struct usb_device_id *id)
+{
+	struct dwav_usb_mt *dwav_usb_mt = NULL;
+	struct input_dev *input_dev = NULL;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	int err = 0;
+
+	endpoint = dwav_usb_mt_get_input_endpoint(intf->cur_altsetting);
+	if (!endpoint)
+		return  -ENXIO;
+
+	dwav_usb_mt = kzalloc(sizeof(struct dwav_usb_mt), GFP_KERNEL);
+	if (!dwav_usb_mt)
+		return  -ENOMEM;
+
+	dwav_usb_mt->dev_id = id->driver_info;
+
+	dwav_usb_mt->finger = kzalloc(sizeof(struct finger_t) *
+				      DEV_INFO[dwav_usb_mt->dev_id].max_finger,
+				      GFP_KERNEL);
+
+	if (!dwav_usb_mt->finger)
+		goto err_free_mem;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		goto err_free_mem;
+
+	dwav_usb_mt->data_size = sizeof(struct dwav_raw);
+	dwav_usb_mt->data = usb_alloc_coherent(udev, dwav_usb_mt->data_size,
+			GFP_KERNEL, &dwav_usb_mt->data_dma);
+	if (!dwav_usb_mt->data)
+		goto err_free_mem;
+
+	dwav_usb_mt->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dwav_usb_mt->irq) {
+		dev_dbg(&intf->dev,
+				"%s - usb_alloc_urb failed: usbtouch->irq\n",
+				__func__);
+		goto err_free_buffers;
+	}
+
+	if (usb_endpoint_type(endpoint) == USB_ENDPOINT_XFER_INT)   {
+		usb_fill_int_urb(dwav_usb_mt->irq, udev,
+			usb_rcvintpipe(udev, endpoint->bEndpointAddress),
+			dwav_usb_mt->data, dwav_usb_mt->data_size,
+			dwav_usb_mt_irq, dwav_usb_mt, endpoint->bInterval);
+	} else {
+		usb_fill_bulk_urb(dwav_usb_mt->irq, udev,
+			 usb_rcvbulkpipe(udev, endpoint->bEndpointAddress),
+			 dwav_usb_mt->data, dwav_usb_mt->data_size,
+			 dwav_usb_mt_irq, dwav_usb_mt);
+	}
+
+	dwav_usb_mt->irq->dev = udev;
+	dwav_usb_mt->irq->transfer_dma = dwav_usb_mt->data_dma;
+	dwav_usb_mt->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	dwav_usb_mt->interface  = intf;
+
+	if (udev->manufacturer)
+		strlcpy(dwav_usb_mt->name,
+				udev->manufacturer, sizeof(dwav_usb_mt->name));
+
+	if (udev->product) {
+		if (udev->manufacturer)
+			strlcat(dwav_usb_mt->name,
+					" ", sizeof(dwav_usb_mt->name));
+
+		strlcat(dwav_usb_mt->name,
+				udev->product, sizeof(dwav_usb_mt->name));
+	}
+
+	if (!strlen(dwav_usb_mt->name)) {
+		snprintf(dwav_usb_mt->name, sizeof(dwav_usb_mt->name),
+				"D-WAV Scientific MultiTouch %04x:%04x",
+				le16_to_cpu(udev->descriptor.idVendor),
+				le16_to_cpu(udev->descriptor.idProduct));
+	}
+
+	usb_make_path(udev, dwav_usb_mt->phys, sizeof(dwav_usb_mt->phys));
+	strlcat(dwav_usb_mt->phys, "/input0", sizeof(dwav_usb_mt->phys));
+
+	usb_to_input_id(udev, &input_dev->id);
+
+	input_dev->dev.parent = &intf->dev;
+
+	err = dwav_usb_mt_init(dwav_usb_mt, (void *)input_dev);
+	if (err)
+		goto err_free_urb;
+
+	usb_set_intfdata(intf, dwav_usb_mt);
+
+	dev_info(&intf->dev, "%s\n", DEV_INFO[dwav_usb_mt->dev_id].name);
+
+	return 0;
+
+err_free_urb:
+	usb_free_urb(dwav_usb_mt->irq);
+
+err_free_buffers:
+	dwav_usb_mt_free_buffers(udev, dwav_usb_mt);
+
+err_free_mem:
+	if (input_dev)
+		input_free_device(input_dev);
+	kfree(dwav_usb_mt);
+
+	return err;
+}
+
+static void dwav_usb_mt_disconnect(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	if (!dwav_usb_mt)
+		return;
+
+	dev_dbg(&intf->dev,
+			"%s - dwav_usb_mt is initialized, cleaning up\n",
+			__func__);
+
+	usb_set_intfdata(intf, NULL);
+
+	/* this will stop IO via close */
+	input_unregister_device(dwav_usb_mt->input);
+
+	usb_free_urb(dwav_usb_mt->irq);
+
+	dwav_usb_mt_free_buffers(interface_to_usbdev(intf), dwav_usb_mt);
+
+	kfree(dwav_usb_mt);
+}
+
+MODULE_DEVICE_TABLE(usb, dwav_usb_mt_devices);
+
+static struct usb_driver dwav_usb_mt_driver = {
+	.name = "dwav_usb_mt",
+	.probe = dwav_usb_mt_probe,
+	.disconnect = dwav_usb_mt_disconnect,
+	.suspend = dwav_usb_mt_suspend,
+	.resume = dwav_usb_mt_resume,
+	.reset_resume = dwav_usb_mt_reset_resume,
+	.id_table = dwav_usb_mt_devices,
+	.supports_autosuspend = 1,
+};
+
+module_usb_driver(dwav_usb_mt_driver);
+
+MODULE_AUTHOR("Hardkernel Co.,Ltd");
+MODULE_DESCRIPTION("D-WAV USB(HID) MultiTouch Driver");
+MODULE_LICENSE("GPL");
+
+MODULE_ALIAS("dwav_usb_mt");
diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index d77f116680a0..916854703530 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -1020,6 +1020,9 @@ static int goodix_get_gpio_config(struct goodix_ts_data *ts)
 			ts->reset_controller_at_probe = true;
 			ts->load_cfg_from_disk = true;
 			ts->irq_pin_access_method = IRQ_PIN_ACCESS_GPIO;
+
+			ts->client->irq = gpiod_to_irq(ts->gpiod_int);
+			dev_info(dev, "IRQ number=%d\n", ts->client->irq);
 		}
 	}
 
diff --git a/drivers/pinctrl/meson/pinctrl-meson.c b/drivers/pinctrl/meson/pinctrl-meson.c
index 530f3f934e19..fad0a2f9cf28 100644
--- a/drivers/pinctrl/meson/pinctrl-meson.c
+++ b/drivers/pinctrl/meson/pinctrl-meson.c
@@ -52,6 +52,7 @@
 #include <linux/property.h>
 #include <linux/regmap.h>
 #include <linux/seq_file.h>
+#include <linux/of_irq.h>
 
 #include "../core.h"
 #include "../pinctrl-utils.h"
@@ -602,6 +603,33 @@ static int meson_gpio_get(struct gpio_chip *chip, unsigned gpio)
 	return !!(val & BIT(bit));
 }
 
+static int meson_gpio_to_irq(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct meson_pinctrl *pc = gpiochip_get_data(chip);
+	struct meson_bank *bank;
+	struct irq_fwspec fwspec;
+
+	if (meson_get_bank(pc, gpio, &bank))
+		return -EINVAL;
+
+	if (bank->irq_first < 0) {
+		dev_warn(pc->dev, "no support irq for pin[%d]\n", gpio);
+		return -EINVAL;
+	}
+
+	if (!pc->of_irq) {
+		dev_err(pc->dev, "invalid device node of gpio INTC\n");
+		return -EINVAL;
+	}
+
+	fwspec.fwnode = of_node_to_fwnode(pc->of_irq);
+	fwspec.param_count = 2;
+	fwspec.param[0] = gpio - bank->first + bank->irq_first;
+	fwspec.param[1] = IRQ_TYPE_NONE;
+
+	return irq_create_fwspec_mapping(&fwspec);
+}
+
 static int meson_gpiolib_register(struct meson_pinctrl *pc)
 {
 	int ret;
@@ -617,6 +645,7 @@ static int meson_gpiolib_register(struct meson_pinctrl *pc)
 	pc->chip.direction_output = meson_gpio_direction_output;
 	pc->chip.get = meson_gpio_get;
 	pc->chip.set = meson_gpio_set;
+	pc->chip.to_irq = meson_gpio_to_irq;
 	pc->chip.base = -1;
 	pc->chip.ngpio = pc->data->num_pins;
 	pc->chip.can_sleep = false;
@@ -680,6 +709,12 @@ static int meson_pinctrl_parse_dt(struct meson_pinctrl *pc)
 	pc->fwnode = gpiochip_node_get_first(pc->dev);
 	gpio_np = to_of_node(pc->fwnode);
 
+	pc->of_irq = of_find_compatible_node(NULL,
+			NULL, "amlogic,meson-gpio-intc");
+	if (!pc->of_irq)
+		pc->of_irq = of_find_compatible_node(NULL,
+			NULL, "amlogic,meson-gpio-intc-ext");
+
 	pc->reg_mux = meson_map_resource(pc, gpio_np, "mux");
 	if (IS_ERR_OR_NULL(pc->reg_mux)) {
 		dev_err(pc->dev, "mux registers not found\n");
diff --git a/drivers/pinctrl/meson/pinctrl-meson.h b/drivers/pinctrl/meson/pinctrl-meson.h
index 34fc4e8612e4..0f9fa04513ea 100644
--- a/drivers/pinctrl/meson/pinctrl-meson.h
+++ b/drivers/pinctrl/meson/pinctrl-meson.h
@@ -134,6 +134,7 @@ struct meson_pinctrl {
 	struct regmap *reg_ds;
 	struct gpio_chip chip;
 	struct fwnode_handle *fwnode;
+	struct device_node *of_irq;
 };
 
 #define FUNCTION(fn)							\
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 39d94c850839..c9c8f34c98f1 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -713,6 +713,7 @@ static const struct spi_device_id spidev_spi_ids[] = {
 	{ .name = "spi-authenta" },
 	{ .name = "em3581" },
 	{ .name = "si3210" },
+	{ .name = "spi-dev" },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, spidev_spi_ids);
@@ -741,6 +742,7 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "semtech,sx1301", .data = &spidev_of_check },
 	{ .compatible = "silabs,em3581", .data = &spidev_of_check },
 	{ .compatible = "silabs,si3210", .data = &spidev_of_check },
+	{ .compatible = "amlogic,spi-dev", .data = &spidev_of_check },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/include/drm/drm_mipi_dbi.h b/include/drm/drm_mipi_dbi.h
index 816f196b3d4c..e49bc44c9221 100644
--- a/include/drm/drm_mipi_dbi.h
+++ b/include/drm/drm_mipi_dbi.h
@@ -209,12 +209,7 @@ int mipi_dbi_buf_copy(void *dst, struct iosys_map *src, struct drm_framebuffer *
 #define mipi_dbi_command(dbi, cmd, seq...) \
 ({ \
 	const u8 d[] = { seq }; \
-	struct device *dev = &(dbi)->spi->dev;	\
-	int ret; \
-	ret = mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
-	if (ret) \
-		dev_err_ratelimited(dev, "error %d when sending command %#02x\n", ret, cmd); \
-	ret; \
+	mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
 })
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/sound/soc/meson/Kconfig b/sound/soc/meson/Kconfig
index b93ea33739f2..9f5e3952e54e 100644
--- a/sound/soc/meson/Kconfig
+++ b/sound/soc/meson/Kconfig
@@ -70,6 +70,8 @@ config SND_MESON_AXG_SOUND_CARD
 	imply SND_MESON_AXG_PDM
 	imply SND_MESON_G12A_TOACODEC
 	imply SND_MESON_G12A_TOHDMITX if DRM_MESON_DW_HDMI
+	imply SND_SOC_MESON_T9015
+	imply SND_SOC_SIMPLE_AMPLIFIER
 	help
 	  Select Y or M to add support for the AXG SoC sound card
 
diff --git a/sound/soc/meson/axg-frddr.c b/sound/soc/meson/axg-frddr.c
index 61f9d417fd60..b0f3883af0a9 100644
--- a/sound/soc/meson/axg-frddr.c
+++ b/sound/soc/meson/axg-frddr.c
@@ -106,7 +106,7 @@ static struct snd_soc_dai_driver axg_frddr_dai_drv = {
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
@@ -181,7 +181,7 @@ static struct snd_soc_dai_driver g12a_frddr_dai_drv = {
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
-- 
2.39.2

